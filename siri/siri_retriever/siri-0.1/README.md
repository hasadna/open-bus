# SIRI client Spring Boot application

## In Short
This application is a Spring Boot application, written in Java.

Its main purpose is to query the MOT (Ministry of Transportation) server for SIRI data.

After cloning this branch of Git, open a console window and do:
```bash
  cd siri-0.1 
  ./mvnw clean package -DskipTests  
  java -jar ./target/bus-0.0.1-SNAPSHOT.jar 
```
(on Windows replace every / with \)

## Background
As part of the open-bus project in הסדנה לידע ציבורי , this application retrieves (from MOT Siri Server) all real-time data about the public transportation buses in Israel, their locations and arrival times.

This SIRI retrieved data can then be combined with GTFS data to get useful insights. This part is not covered by this application!

This application, in the micro-services architectural style, limits itself to retrieving and storing the SIRI real-time data (so it can later be used in various ways).

## Context View
The application constantly retrieves data from MOT SIRI server by sending SOAP request, and receiving SOAP responses.

The applications parses the SOAP responses, and creates CSV lines containing the useful data from each response.

The application stores all useful data that was retrieved in CSV (text) files. (These files can later be imported to a relational database, or processed in any other way).

The application uses internal JSON files (siri.schedule.json) with details on which bus routes to query, and how frequently. These files are generated by another microservice (GTFS-Reader) that runs on the same machine.

(embed drawing here)



## Functional View

## Information View

### Scheduling Data Files

In order to determine which routes/stops to query, and when, the Siri-Retriever application reads Scheduling data files from a pre-configured directory on the file system (property *scheduler.data.file*).

The Siri-Retriever reads all files in that directory that start with "siri.scheduled" and end with ".json". 

The current convention is to have several such files, each one for routes of a different agency. So, for exmample, the file siri.schedule.16.json contains routes of agency 16 (Superbus), and the file siri.schedule.5.json contains routes of agency 5 (Dan).

These files are generated by the GTFS-Reader microservice, every night at about 3:30 AM, after it downloads the latest GTFS file.

Each file has a format like the following example:

```json

{  "data" :[{
  "description" : " --- קו 1 בבאר יעקב  --- Makat 90001  --- Direction 3  --- Alternative 0  ------  Thursday  ------  [05:30, 06:00, 06:30, 07:00, 07:30, 08:00, 08:45, 09:30, 10:30, 11:30, 12:35, 13:35, 14:37, 15:15, 15:45, 16:37, 17:07, 18:05, 19:05, 20:05, 21:05, 22:05]",
  "makat" : "90001",
  "lineShortName" : "1",
  "stopCode" : "33731",
  "previewInterval" : "PT2H",
  "lineRef" : "20159",
  "maxStopVisits" : "7",
  "executeEvery" : "60",
  "departureTimes" : {
    "THURSDAY" : [ "05:30", "06:00", "06:30", "07:00", "07:30", "08:00", "08:45", "09:30", "10:30", "11:30", "12:35", "13:35", "14:37", "15:15", "15:45", "16:37", "17:07", "18:05", "19:05", "20:05", "21:05", "22:05" ]
  },
  "lastArrivalTimes" : {
    "THURSDAY" : "22:19:37"
  }
},{
  "description" : " --- קו 1 בביתר עילית  --- Makat 72001  --- Direction 3  --- Alternative #  ------  Thursday  ------  [00:00, 00:15, 00:30, 05:40, 06:20, 06:40, 07:00, 07:20, 07:30, 07:40, 07:50, 08:00, 08:05, 08:15, 08:25, 08:35, 08:45, 09:00, 09:12, 09:24, 09:36, 09:48, 19:24, 19:36, 19:48, 20:00, 20:12, 20:24, 20:36, 20:48, 21:00, 21:15, 21:30, 21:45, 22:00, 22:15, 22:30, 22:45, 23:00, 23:15, 23:30, 23:45]",
  "makat" : "72001",
  "lineShortName" : "1",
  "stopCode" : "60101",
  "previewInterval" : "PT2H",
  "lineRef" : "10509",
  "maxStopVisits" : "7",
  "executeEvery" : "60",
  "departureTimes" : {
    "THURSDAY" : [ "00:00", "00:15", "00:30", "05:40", "06:20", "06:40", "07:00", "07:20", "07:30", "07:40", "07:50", "08:00", "08:05", "08:15", "08:25", "08:35", "08:45", "09:00", "09:12", "09:24", "09:36", "09:48", "19:24", "19:36", "19:48", "20:00", "20:12", "20:24", "20:36", "20:48", "21:00", "21:15", "21:30", "21:45", "22:00", "22:15", "22:30", "22:45", "23:00", "23:15", "23:30", "23:45" ]
  },
  "lastArrivalTimes" : {
    "THURSDAY" : "24:23:21"
  }
}
... 
]}
```
The important fields are: *linerRef* (route Id in GTFS terminology), *stopCode* (code of last stop on the route), and *nextExecution*

*nextExecution* does not appear in the JSON, but it is populated by the scheduler at runtime, and contains the date-time of the next query to Siri for that route. I order to determine the time of next execution, the Scheduler uses the value of the field *executeEvery*, which is the desired number of seconds between 2 queries for that route.

The list of *departureTimes* for each day of the week, is used by Siri-Retriever to reduce the frequency of queries for each route, when it is not "active". i.e if the first bus starts at 5:40 AM, the Siri-Retriever will start querying for that route only a few minutes before that hour.

### number of intervals

There is a file called data.xml
It is imported as a resource in BusApplication.java:
```java
@SpringBootApplication
@EnableCaching
@EnableAsync
@EnableRetry
@ImportResource({"classpath:data.xml"})
public class BusApplication {

```
it defines a map named "longLines". 
This map is imported in SiriConsumeServiceImpl.java:
```java
@Component
@Profile({"production", "integrationTests"})
public class SiriConsumeServiceImpl implements SiriConsumeService {

    @Value("${number.of.intervals:12}")
    int numberOfIntervals ;

    @Value("${duration.of.interval.in.minutes:5}")
    int durationOfIntervalInMinutes ;

    @Resource(name="longLines")
    Map<String, Integer> longLines;

```
and used in method decideNumberOfIntervals()
```java
    private int decideNumberOfIntervals(String lineRef) {
        return longLines.getOrDefault(lineRef, numberOfIntervals);
    }

```
which is used in

```java
    private String buildServiceRequest(String stopCode, String previewInterval, String lineRef, int maxStopVisits) {
        int numberOfIntervalsForThisRoute = decideNumberOfIntervals(lineRef);   // might increase number of intervals according to config
        final String oneStopServiceRequestXml = generateStopMonitoringServiceRequestTemplate(numberOfIntervalsForThisRoute);    // 12 intervals of 5 minutes
```

number of intervals is used when generating the SOAP request to SIRI
```java
    private String generateStopMonitoringServiceRequestTemplate(int numberOfIntervals) {
        String template = "" +
                "<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"\n" +
                "                   xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\" xmlns:acsb=\"http://www.ifopt.org.uk/acsb\"\n" +
                "                   xmlns:datex2=\"http://datex2.eu/schema/1_0/1_0\" xmlns:ifopt=\"http://www.ifopt.org.uk/ifopt\"\n" +
                "                   xmlns:siri=\"http://www.siri.org.uk/siri\" xmlns:siriWS=\"http://new.webservice.namespace\"\n" +
                "                   xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n" +
                "                   xsi:schemaLocation=\"http://192.241.154.128/static/siri/siri.xsd\">\n" +
                "    <SOAP-ENV:Header/>\n" +
                "    <SOAP-ENV:Body>\n" +
                "        <siriWS:GetStopMonitoringService>\n" +
                "            <Request xsi:type=\"siri:ServiceRequestStructure\">\n" +
                "                <siri:RequestTimestamp>__TIMESTAMP__</siri:RequestTimestamp>\n" +
                "__REQUESTS__" +
                "            </Request>\n" +
                "        </siriWS:GetStopMonitoringService>\n" +
                "    </SOAP-ENV:Body>\n" +
                "</SOAP-ENV:Envelope>\n" ;
        String s = "" ;
        logger.trace("generating {} intervals", numberOfIntervals);
        for (int i = 0 ; i < numberOfIntervals ; i = i + 1) {   // intervals of 5 minutes
            s = s + generateStopMonitoringRequestTemplate(i*durationOfIntervalInMinutes);
        }
        return template.replace("__REQUESTS__", s);

    }
```

To summarize - when creating a SOAP request to SIRI, we actually create 12 requests.
Each request queries the __last bus-stop__.
Each such request will query from a future time defined as interval*5 minutes. (interval is 0 to 11).
Each request receives as response the first 3 buses that will arrive after the defined future time.

For some bus lines this is not enough, so we allow them more queries into the future (currently 24 intervals of 5 minutes). These bus lines are defined in data.xml.
This is because the length of the ride (from start point to end point) is more than 1 hour.
Since we query the __last__ bus-stop, if we query only 1 hour into the future, we will not receive in any response the (more than 3) buses that will arrive to the last bus-stop more than a 1 hour in the future.

This  limitation will be fixed by issue #316 (dynamic windows)

### CSV Output Files

## Development View

# FAQ